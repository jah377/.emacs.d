#+TITLE: My GNU Emacs Configuration
#+DATE: Wednesday, September 25, 2024
#+PROPERTY: header-args:emacs-lisp :results silent
#+STARTUP: overview

* Introduction

This is my literate Emacs configuration file; there are many like it,
but this one is mine. It serves as both documentation and the source
for configuring Emacs. All necessary config files are generated from
this file by calling ~org-babel-tangle~ (~C-c C-v t~), and stored in the
=/modules= sub-directory. As such, changes should be made in this
document, not in the individual config files.

*N.B.* Modules are individually imported in [[*Conclusion][Conclusion]].

* early-init.el

The =early-init.el= file, introduced with Emacs27, is the first file
that Emacs reads when starting up (before =init.el=). In principal, the
early initialization file should set-up a few basic things before
Emacs produces the initial frame, and should not depend on any
packages.

#+begin_src emacs-lisp :tangle early-init.el
;;; -*- lexical-binding: t -*-
#+end_src

** Temporarily Configure Garbage Collection

Garbage collection (GC) ensures that a program does not exceed its
memory quote or reach a point that it can no longer function. It also
frees up developers from having to manually manage a program's memory
which, in turn, reduces the potential for memory-related bugs.

However, GC can extend startup time. Therefore, we (temporarily) set
~gc-cons-threshold~ to a very large number -- effectively disabling
garbage collection. Otherwise Emacs might freeze. This strategy is
used by =Doom-Emacs= [[[https://github.com/doomemacs/doomemacs/blob/master/early-init.el][doomemacs/early-init.el]]].

*N.B.* This value is reset later in [[*Reset Garbage Collection][Reset Garbage Collection]].

#+begin_src emacs-lisp :tangle early-init.el
;; Temporarily increase garbage collect for fast startup
(setopt gc-cons-threshold most-positive-fixnum)
#+end_src

** Disable Frame Resizing

Changing the font, bars, and fringes may resize the frame in order to
preserve the number of columns or lines it displays. It is said that
this affects startup times.

Set prior to [[*Disable UI Elements][Disable UI Elements]] as those changes may affect frame
resizing?

+ Damien Cassou :: [[https://github.com/DamienCassou/emacs.d/blob/master/early-init.el#L25][github.com/early-init.el]]
+ Tony Zorman :: [[https://tony-zorman.com/posts/emacs-potpourri.html][A Potpourri of Emacs Tweaks]]

#+begin_src emacs-lisp :tangle early-init.el
;; Inhibit frame resizing due to visual settings
(setopt frame-inhibit-implied-resize t)
#+end_src

** Disable UI Elements

#+begin_src emacs-lisp :tangle early-init.el
;; Prevent gimpse of un-styled Emacs
(menu-bar-mode   -1)
(scroll-bar-mode -1) ; Visible scrollbar
(scroll-all-mode -1) ; Synchronized scrolling of buffers
(tool-bar-mode   -1)
(tooltip-mode    -1)

;; No need for splash screen and echo area message
(setq-default inhibit-startup-screen t     ; disable start-up screen
              inhibit-startup-message t    ; disable start-up message
              initial-scratch-message nil  ; Empty initial *scratch* buffer
              initial-buffer-choice t      ; Open *scratch* buffer at init
              initial-major-mode 'org-mode)
#+end_src

** Disable (Some) Warnings

According to [[https://github.com/Thaodan/emacs.d][github/Thaodan]], some packages store their data in Elisp
files without lexical bindings or simply don't use it yet. These
warnings are annoying.

#+begin_src emacs-lisp :tangle early-init.el
;; Suppress warnings about lexical bindings.
;; https://github.com/Thaodan/emacs.d
(setopt warning-suppress-types '((lexical-binding)))
#+end_src
* init.el

#+begin_src emacs-lisp :tangle init.el
;;; -*- lexical-binding: t -*-

;; Profile emacs startup
;; https://github.com/LionyxML/emacs-kick/blob/master/init.el
(add-hook 'after-init-hook
          (lambda ()
            (with-current-buffer (get-buffer-create "*scratch*")
              (insert (format "*Welcome to Emacs!*

+ Loading time :: %s secs
+ Packages :: %s
+ Garbage Collections :: %s"
                              (emacs-init-time "%.2f")
                              (number-to-string (length package-activated-list))
                              gcs-done)))))
#+end_src

** Initialize Package Resources

#+begin_src emacs-lisp :tangle init.el
;; Initialize package resources
(require 'package)
(setopt package-archives
      '(("gnu elpa"  . "https://elpa.gnu.org/packages/")
        ("melpa"     . "https://melpa.org/packages/")
        ("nongnu"    . "https://elpa.nongnu.org/nongnu/"))
      package-archive-priorities
      '(("melpa"    . 6)
        ("gnu elpa" . 5)
        ("nongnu"   . 4)))
(package-initialize)
#+end_src

** Setup 'use-package'

#+begin_src emacs-lisp :tangle init.el
;; Is this still necessary since 'use-package' now builtin?
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

;; Standardize `use-package` settings
(require 'use-package-ensure)
(setopt use-package-always-ensure t
        use-package-compute-statistics t
        use-package-verbose t)
#+end_src

** Tidy Emacs Directory

Default paths used to store configuration files and persistent data
are not consistent across Emacs packages, and are often dumped into
~user-emacs-directory~. Alternatively, the =no-littering= package stores
config and data files in =/etc= and =/var= sub-directories of
~user-emacs-directory~.

#+begin_src emacs-lisp :tangle init.el
(use-package no-littering
  :demand t
  :config
  ;; Save customizations in 'etc' sub-directory and load on startup
  (setopt custom-file (no-littering-expand-etc-file-name "custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file)))
#+end_src

** Reset Garbage Collection

In [[*Temporarily Configure Garbage Collection][Temporarily Configure Garbage Collection]] we maximized GC thresholds
to improve startup time. Here, we use =Doom-Emacs=' "Garbage Collection
Magic Hack" package [[[https://github.com/emacsmirror/gcmh][github/gcmh]]] to reset these values and enforce a
"sneaky" GC strategy.

#+begin_src emacs-lisp :tangle init.el
;; Garbage Collection Magic Hack
(use-package gcmh
  :init (gcmh-mode 1)
  :hook
  (after-init . garbage-collect)

  ;; Must reset GC threshold values after initialization
  (emacs-startup . (lambda () (setopt gc-cons-percentage 0.1
                                      gc-cons-threshold (* 32 1024 1024)
                                      gcmh-high-cons-threshold (* 32 1024 1024)
                                      gcmh-idle-delay 30))))
#+end_src

It is recommended that we perform garbage collection when not actively
using Emacs. Therefore, we perform GC if idle for 30 seconds.(credit:
[[https://emacs.stackexchange.com/questions/34342/is-there-any-downside-to-setting-gc-cons-threshold-very-high-and-collecting-ga][StackExchange]])

#+begin_src emacs-lisp :tangle init.el
;; Idle garbage collecting
(run-with-idle-timer 30 t (lambda () (garbage-collect)))
#+end_src

** Better Defaults

Here, we configure default built-in Emacs settings and modes.

*** Frame + Buffers

#+begin_src emacs-lisp :tangle init.el
;; Change frame title w.r.t. current buffer
(setopt frame-title-format
        '("emacs: " (:eval (if (buffer-file-name)
                               (abbreviate-file-name (buffer-file-name)) "%b"))))

;; Maximize frame size at init
(add-to-list 'default-frame-alist '(fullscreen . maximized))

;; Unique buffers of identical files denoted with parent directory name
(setopt uniquify-buffer-name-style 'forward)
#+end_src

#+begin_src emacs-lisp :tangle init.el
;; Built-in mode to record changes in the windows configuration
;; See 'winner-undo' and 'winner-redo' functions
(winner-mode 1)
#+end_src

*** Prompts

#+begin_src emacs-lisp :tangle init.el
;; Too lazy to type 'yes-or-no'
(setopt use-short-answers t)
(fset 'yes-or-no-p 'y-or-n-p)

;; Kill buffer, even if live process attached
;; https://www.masteringemacs.org/article/disabling-prompts-emacs
(setopt kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+end_src

*** Mini-Buffer
**** Recursive Minibuffer

#+begin_src emacs-lisp :tangle modules/my-completion.el
;; Support opening new minibuffers from inside existing minibuffers
(setopt enable-recursive-minibuffers t)
#+end_src

**** Prompt Indicator to 'completing-read-multiple'

Recommended in the configuration of =vertico= package [[[https://github.com/minad/vertico][github/vertico]]],
the custom function ~crm-indicator~ adds an indicator to the completion
prompt when using ~completing-read-multiple~ which can be useful for
visually distinguishing prompts or results.

#+begin_src emacs-lisp :tangle modules/my-completion.el
(defun crm-indicator (args)
  "Add indicator to completion promp when using 'completing-read-multiple'"
  (cons (format "[CRM%s] %s"
                (replace-regexp-in-string
                 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                 crm-separator)
                (car args))
        (cdr args)))
(advice-add #'completing-read-multiple :filter-args #'crm-indicator)
#+end_src

For example, calling the example function ~test-crm-indicator~ indicates
that selecting multiple options is both possible using a
comma-separator. *N.B.* src-block not tangled to configuration file.

#+begin_src emacs-lisp :tangle no
(defun test-crm-indicator ()
  "A custom function using completing-read-multiple."
  (interactive)
  (let ((choices '("Option A" "Option B" "Option C")))
    (completing-read-multiple "Choose options: " choices)))
#+end_src

**** Make Minibuffer Prompt Read-Only

Again, recommended in the configuration of the =vertico= package
[[[https://github.com/minad/vertico][github/vertico]]]. This code defines the minibuffer prompt to be
read-only and makes the cursor intangible when it is over the
minibuffer prompt. In other words, text in the minibuffer cannot be
selected or modified by the cursor. This can be useful for creating a
visually distinct and non-editable minibuffer prompt.

#+begin_src emacs-lisp :tangle modules/my-completion.el
(setopt minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

For example if ~(setopt minibuffer-prompt-properties nil)~ and we call
~M-x~, it would be possible to modify the prompt by moving the cursor
back ~C-b~ and deleting M, -, or x. _Not ideal_.

**** Close Minibuffer Regardless of Point Location

#+begin_src emacs-lisp :tangle init.el
;; Closes minibuffer regardless of point location
(advice-add 'keyboard-quit :before (lambda ()
                                     (when (active-minibuffer-window)
                                       (abort-recursive-edit))))
#+end_src

*** Indentation Style

#+begin_src emacs-lisp :tangle init.el
;; Disable 'TAB' for indentation
(setq-default indent-tabs-mode nil)

;; Use 'TAB' for auto-completion selection
(setq-default tab-always-indent 'complete)

;; Number of spaces occupied by 'TAB'
(setq-default tab-width 4
              standard-indent 4)
#+end_src

*** Whitespace

The builtin =whitespace-mode= is useful for visualizing and
automatically cleaning up white-spaces in our buffers. [[https://www.emacswiki.org/emacs/WhiteSpace][Emacswiki]]
provides a nice overview of the settings.

The ~whitespace-style~ variable specifies how blank white-spaces are
visualized and the following are included in our configuration:

  + face :: Enable all visualization via faces. Required for
    visualization of many white-spaces listed below.
  + trailing :: Trailing blanks are visualized via faces.
  + lines-tail :: Columns beyond ~whitespace-line-column~ are
    highlighted via faces (must exclude =lines= in our configuration).
  + empty :: Empty lines at beginning/end of buffer are visualized.
  + indentation::space :: TABs at beginning of lines are visualized.
  + space-before-tab::tab :: SPACEs before TAB are visualized.

#+begin_src emacs-lisp :tangle init.el
;; Built-in Emacs variable highlights empty lines
(setopt indicate-empty-lines t)

;; Visualize whitespace and remove on cleanup
(use-package whitespace
  :hook ((prog-mode . whitespace-mode)
         (before-save . whitespace-cleanup)
         ;; Org-links are always long
         (org-mode . (lambda () (whitespace-mode 0)))
         ;; Whitespace-mode a bit aggressive if editing make files
         (makefile-mode . (lambda ()
                            (setopt indent-tabs-mode t
                                    whitespace-mode nil)
                            (add-hook 'before-save-hook
                                      #'delete-trailing-whitesapce))))
  :custom
  (whitespace-line-column 79 "Highlight text beyond column")
  (whitespace-style '(face
                      trailing
                      lines-tail
                      empty
                      indentation::space
                      space-before-tab::tab))
  :config
  ;; Turn off global whitespace mode
  (global-whitespace-mode 0))
#+end_src

*** Mouse/Scrolling

#+begin_src emacs-lisp :tangle init.el
(setopt  mouse-wheel-scroll-amount '(1 ((shift) . 1)) ; scroll one line at a time
         mouse-wheel-progressive-speed nil            ; don't accelerate scrolling
         mouse-wheel-follow-mouse 't                  ; scroll window under mouse
         mouse-yank-at-point t)                       ; Mouse paste at point, not cursor

;; Scrolling at end of document adds one line
(setopt scroll-step 1)

;; Use pixel scrolling instead of by line
;; https://tony-zorman.com/posts/emacs-potpourri.html
(pixel-scroll-precision-mode 1)
#+end_src

*** Cursor

#+begin_src emacs-lisp :tangle init.el
(setq-default cursor-type 'bar)

;; Flash cursor location when switching buffers
(use-package beacon
  :config (beacon-mode 1))
#+end_src

*** Writing

#+begin_src emacs-lisp :tangle init.el
;; Replace active region by typing text
(delete-selection-mode 1)

;; Specify desired column width of buffer
(setopt fill-column 79)

;; Built-in Emacs minor-mode wraps long text to next line
(global-visual-line-mode 1)

;; Use 'fancy' ellipses for truncated strings
(setopt truncate-string-ellipsis "...")
#+end_src

*** Highlighting

#+begin_src emacs-lisp :tangle init.el
;; Highlight line containing point
(global-hl-line-mode)

;; Highlight matching parentheses
(use-package paren
  :custom
  (show-paren-style 'parenthesis "Only highlight ()")
  (show-paren-when-point-inside-paren t)
  (show-paren-when-point-in-periphery t)
  ;; If cursor on ), show overlay for (
  (show-paren-context-when-offscreen 'overlay)
  :config (electric-pair-mode 1))

;; Highlight killed region
;; https://www.youtube.com/watch?v=oQ9JE9kRwG8
(defun gopar/pulse-current-region (&rest _)
  "pulse the current implicit or active region"
  (if mark-active
      (pulse-momentary-highlight-region (region-beginning) (region-end))
    (pulse-momentary-highlight-region (mark) (point))))

(advice-add #'kill-ring-save :before #'gopar/pulse-current-region)
#+end_src

*** Bookmarks

The built-in =bookmark.el= package allows us to quickly store and access
specific locations in frequently visited files. I mostly use the
following functions:

+ bookmark-set :: ~C-x r m~; Set bookmark at current location
  - Prompt user for desired name of bookmark
  - Bookmarked locations indicated by flag in fringe of buffer
  - Bookmark details stored in =bookmark-alist=
+ bookmark-jump :: ~C-x r b~; Select bookmark and jump to location
+ bookmark-save :: Export =bookmark-alist= to specified file
+ bookmark-delete :: Delete bookmark in =bookmark-alist=
+ bookmark-bmenu-list :: Open buffer containing all bookmarks

*N.B.* The built-in =register.el= package is a more temporary alternative
to =bookmark=, and are assigned to a single character instead of a
name. For more information, checkout this [[https://www.youtube.com/watch?time_continue=3&v=RLPU65RLiC4&embeds_referring_euri=https%3A%2F%2Fwww.reddit.com%2F][youtube video]]. I have not
explored registers much.

#+begin_src emacs-lisp :tangle init.el
(use-package bookmark
  :custom
  ;; By default 'no-littering' package stores bookmark file to 'var/',
  ;; which is lost if performing a "fresh" Emacs install. To persist,
  ;; set 'bookmark-default-file' to store in personal 'scratch/'
  ;; directory.  (bookmark-default-file "~/scratch/jon/.bookmarks.el")
  (bookmark-save-flag t "Save bookmarks when Emacs killed")
  (bookmark-fringe-mark t "Non-nil to show icon in fringe"))
#+end_src

*** File Encoding

[[https://blog.hubspot.com/website/what-is-utf-8][UTF-8]] is central to the storage and encoding of text and
files. Although other encoding systems exist, =utf-8= is practically a
standard, at least in the West, and so it is important that we
instruct Emacs to treat files as UTF-8 by default (credit:
[[https://www.masteringemacs.org/article/working-coding-systems-unicode-emacs][MasteringEmacs]]).

#+begin_src emacs-lisp :tangle init.el
(set-default-coding-systems 'utf-8)

;; Accept 'UTF-8' (uppercase) as a valid encoding in the coding header
;; https://github.com/Thaodan/emacs.d
(define-coding-system-alias 'UTF-8 'utf-8)
#+end_src

*** Line Numbers

#+begin_src emacs-lisp :tangle init.el
;; Show column number in the modeline
(column-number-mode t)

;; Display line numbers in prog-mode
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

*** Images

See also [[*Org Images][Org Images]].

#+begin_src emacs-lisp :tangle init.el
;; Open image files + automatically update buffer if image changes
(auto-image-file-mode 1)
(add-hook 'image-mode-hook 'auto-revert-mode)
#+end_src

*** Ediff

#+begin_src emacs-lisp :tangle init.el
;; Show ediffs in single window between left/right buffers
(setopt ediff-split-window-function 'split-window-horizontally
        ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

* my-visuals.el
** Visual Advice

#+begin_src emacs-lisp :tangle modules/my-visuals.el
;;; -*- lexical-binding: t -*-

;; Discard all themes before loading next
(define-advice load-theme (:before (&rest _args) theme-dont-propagate)
  (mapc #'disable-theme custom-enabled-themes))
#+end_src

** Theme

#+begin_src emacs-lisp :tangle modules/my-visuals.el
(use-package doom-themes
  :ensure t
  :config
  ;; Global settings (defaults)
  (setopt doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)

  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
#+end_src

** Toggle Light & Dark Themes

#+begin_src emacs-lisp :tangle modules/my-visuals.el
(defun light ()
  (interactive)
  (load-theme 'doom-tomorrow-day t))

(defun dark ()
  (interactive)
  (load-theme 'doom-one t))

(dark)
#+end_src

** Icons

#+begin_src emacs-lisp :tangle modules/my-visuals.el
(use-package nerd-icons
  :config
  ;; Download nerd-icons if directory not found
  (unless (car (file-expand-wildcards
                (concat user-emacs-directory "elpa/nerd-icons-*")))
    (nerd-icons-install-fonts t)))
#+end_src

** Font

Example of emphasis markers in org-mode include *bold*, ~code~, =verbatim=,
/italics/, _underline_.

The following fonts were downloaded and added to the configuration by
doing the following:

+ Jetbrains Mono :: Manually downloaded from [[https://www.jetbrains.com/lp/mono/][jetbrains.com]]. The font
  was installed by following the [[https://www.jetbrains.com/lp/mono/#how-to-install][how-to]] instructions verbatim.

*N.B.* This section pulls heavily from [[https://github.com/daviwil/dotfiles/blob/emacs-home-service/.emacs.d/modules/dw-core.el][github/daviwil/.emacs.d]].

#+begin_src emacs-lisp :tangle modules/my-visuals.el
;; Set fonts
(set-face-attribute 'default nil
                    :font "JetBrains Mono"
                    :height 100
                    :weight 'medium)

(set-face-attribute 'fixed-pitch nil
                    :font "JetBrains Mono"
                    :height 100
                    :weight 'medium)

(set-face-attribute 'variable-pitch nil
                    :font "JetBrains Mono"
                    :height 100
                    :weight 'medium)

;; Modified from https://stackoverflow.com/a/50052751
(defun set-font-size ()
  "Set the font-pt size."
  (interactive)
  (let* ((pt-size (string-to-number (read-string "Font size: ")))
         (font-height (* 10 pt-size)))
    (set-face-attribute 'default nil :height font-height)))
#+end_src

** Modeline

#+begin_src emacs-lisp :tangle modules/my-visuals.el
(use-package doom-modeline
  :config (doom-modeline-mode 1)
  :custom
  ;; Display project_name/../file_name
  (doom-modeline-buffer-file-name-style 'truncate-with-project)
  (doom-modeline-buffer-encoding nil "Dont care about UTF-8 badge")
  (doom-modeline-vcs-max-length 30   "Limit branch name length")
  (doom-modeline-enable-word-count t "Turn on wordcount"))
#+end_src

** Additional Highlighting

*N.B.* Built-in Emacs settings set in [[*Highlighting][Highlighting]]

#+begin_src emacs-lisp :tangle modules/my-visuals.el
;; Highlight occurrences of the same text in buffer
(use-package highlight-thing
  :demand t
  :hook ((prog-mode . highlight-thing-mode)
         (org-mode . highlight-thing-mode))
  :custom
  (highlight-thing-exclude-thing-under-point t)
  (highlight-thing-case-sensitive-p t)
  (highlight-thing-ignore-list
   '("False" "True", "return", "None", "if", "else", "self",
     "import", "from", "in", "def", "class")))
#+end_src

** Provide Visuals

#+begin_src emacs-lisp :tangle modules/my-visuals.el
(provide 'my-visuals)
#+end_src

* my-org.el
** Org Basics

#+begin_src emacs-lisp :tangle modules/my-org.el
;;; -*- lexical-binding: t -*-

;; The essentials
(use-package org
  :demand t
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c c" . org-capture))
  :hook ((org-src-mode . whitespace-cleanup)
         ;; Automatic break line at 'current-fill-column' (line wrapping)
         (org-mode . turn-on-auto-fill))
  :custom
  (org-ellipsis " ")
  (org-startup-folded t    "Always fold headers")
  (org-startup-indented t  "Visually indent at startup")
  (org-adapt-indentation t "Align contents with heading")
  (org-element-use-cache nil "Avoid 'org-element--cache' error")
  ;; Link to ID not heading text; avoids broken links should heading change
  (org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
#+end_src

** Org Appearance
*** Modernize Org UI

#+begin_src emacs-lisp :tangle modules/my-org.el
;; "Modernizes" UI experience of 'org-mode'
(use-package org-modern
  :after org
  :init (global-org-modern-mode)
  :hook ((org-mode                 . org-modern-mode)
         (org-agenda-finalize-hook . org-modern-agenda))
  :commands (org-modern-mode org-modern-agenda))
#+end_src

*** Emphasis Markers

#+begin_src emacs-lisp :tangle modules/my-org.el
(setopt org-hide-emphasis-markers t)

;; Interactively toggle visability if cursor between markers
(use-package org-appear
  :after org
  :hook (org-mode . org-appear-mode)
  :custom (org-appear-inside-latex t))
#+end_src

** Org Key Behavior

#+begin_src emacs-lisp :tangle modules/my-org.el
;; 'C-a/e' jump to start-end of headline text
(setopt org-special-ctrl-a/e t)

;; 'C-k' behave different on headline text
(setopt org-special-ctrl-k t)

;; Do not delete hidden subtree with 'C-k'
(setopt org-ctrl-k-protect-subtree t)

;; ? speed-key opens Speed Keys help.
(setopt org-use-speed-commands
      ;; If non-nil, 'org-use-speed-commands' allows efficient
      ;; navigation of headline text when cursor is on leading
      ;; star. Custom function allows use of Speed keys if on ANY
      ;; stars.
      (lambda ()
        (and (looking-at org-outline-regexp)
             (looking-back "^\**"))))
#+end_src

** Org Images

#+begin_src emacs-lisp :tangle modules/my-org.el
(setopt org-startup-with-inline-images t
        ;; Allow for inline display of remote images
        org-display-remote-inline-images 'cache)

;; Refresh inline images after executing an 'src-block'
(add-hook 'org-babel-after-execute-hook
          (lambda () (org-display-inline-images nil t)))
#+end_src

** Org-Babel
*** General Org-Babel Settings

#+begin_src emacs-lisp :tangle modules/my-org.el
(setopt org-confirm-babel-evaluate nil
      org-src-window-setup 'current-window
      org-src-ask-before-returning-to-edit-buffer t)

;; Remove code indentation in org-src blocks
(setopt org-src-preserve-indentation t)
#+end_src

*** FIX: Display ANSI Error Colors

#+begin_src emacs-lisp :tangle modules/my-org.el
;; https://github.com/emacs-jupyter/jupyter/issues/366
(defun display-ansi-colors ()
  (ansi-color-apply-on-region (point-min) (point-max)))
#+end_src

** Org Templates
*** Org-Block Templates

#+begin_src emacs-lisp :tangle modules/my-org.el
(setopt org-structure-template-alist
      '(("x" . "example")
        ("q" . "quote")
        ("e" . "src emacs-lisp")
        ("m" . "src emacs-lisp :tangle modules/my-")
        ("s" . "src sh")
        ("p" . "src python")))
#+end_src

** Provide my-org

#+begin_src emacs-lisp :tangle modules/my-org.el
(provide 'my-org)
#+end_src

* my-dired.el
:PROPERTIES:
:ID:       20596bd1-da74-408e-a84e-0b5b9f240398
:END:

The built-in =dired= package provides core functionality for navigating
directories and performing file operations within a =dired=-buffer.

#+begin_src emacs-lisp :tangle modules/my-dired.el
;;; -*- lexical-binding: t -*-

(use-package dired
  :ensure nil
  :commands dired
  :after my-functions
  :custom
  ;; -A :: Show hidden files but omit implied '.' and '..' targets
  ;; -h :: Make file sizes human-readable
  ;; -l :: Produce long=g, detailed listing (required by 'dired')
  ;; -v :: Sort file by version number
  ;; --group-directories-first :: List directories at top of buffer
  ;; --time-style=long-iso     :: List %Y-%m-%d %H:%M
  (dired-listing-switches (concat "-Ahlv"
                                  " --group-directories-first"
                                  " --time-style=long-iso"))

  ;; Refresh 'dired' buffer if directory changes
  (dired-auto-revert-buffer #'dired-buffer-changed-p)

  ;; If two 'dired' buffers open side-by-side, Emacs will suggest the
  ;; other buffer directory when moving files
  (dired-dwim-target t)

  :config

  ;; The variable 'dired-kill-when-opening-new-dired-buffer'
  ;; exists. However, there are use-cases for having multiple 'dired'
  ;; buffers open at the same time (see 'dired-dwim-target').
  (defun jh/dired-kill-all-buffers ()
    "Delete all open 'dired'-mode buffers."
    (interactive)
    (jh/kill-buffers-by-mode 'dired-mode)))
#+end_src

** Dired-X

The built-in =dired-x= package builds on =dired.el= by providing extended
and optional features including, but not limited to:

+ Omitted files :: =dired-omit-mode= tidies the =dired= buffer by hiding
  files based on regex patterns

+ Jumping to files :: Adds commands to quickly jump to files or
  directories in a project

#+begin_src emacs-lisp :tangle modules/my-dired.el
(use-package dired-x
  :ensure nil
  :after dired
  :command dired
  :custom
  ;; Files to ignore in 'dired' buffer.
  (dired-omit-files (concat dired-omit-files
                            "\|"
                            (rx (or (: bos (or "\.DS_Store"
                                               "__MACOSX"
                                               "\.git")
                                       eos)
                                    (: bos "__pycache__")
                                    ".ipynb_checkpoints"
                                    "\.~.*#"))))
  :config
  ;; Must activate 'dired-omit-mode' to omit 'dired-omit-files'.
  (add-hook 'dired-after-readin-hook 'dired-omit-mode))
#+end_src

** Dired-Aux

Finally, the =dired-aux= package includes auxiliary functions to support
additional functionality in =dired=, including (but not limited to):

+ Bulk operations :: Handle operations on multiple files more
  robustly, such as renaming and copying

+ File compression and decompression :: Adds commands for compressing
  and decompressing files directly from a =dired= buffer

+ Backup and auto-save file cleanup :: Includes features to clean up
  backup files and other temporary files more effectively

#+begin_src emacs-lisp :tangle modules/my-dired.el
(use-package dired-aux
  :ensure nil
  :after dired
  :command dired
  :bind (:map dired-mode-map
              ;; C-+ calls 'er/expand-region'
              ("M-+" . dired-create-empty-file))
  :custom
  ;; Revert dired-buffer after 'dired-do' operations
  (dired-do-revert-buffer t))
#+end_src

** wDired

The built-in ~wDired~ package is used to make =dired=-buffers
writable. This is useful for quickly renaming multiple files.

#+begin_src emacs-lisp :tangle modules/my-dired.el
(use-package wdired
  :ensure nil
  :after dired
  :command dired
  :commands (wdired-change-to-wdired-mode)
  :custom
  ;; Change permission using 'SPC'
  (wdired-allow-to-change-permissions t))
#+end_src

** Dired Icons

#+begin_src emacs-lisp :tangle modules/my-dired.el
(use-package nerd-icons-dired
  :ensure nil
  :after (dired nerd-icons)
  :hook (dired-mode))
#+end_src

** Provide my-dired.el

#+begin_src emacs-lisp :tangle modules/my-dired.el
(provide 'my-dired)

;;; my-dired.el ends here
#+end_src

* my-completion.el

#+begin_src emacs-lisp :tangle modules/my-completion.el
;;; -*- lexical-binding: t -*-
#+end_src

** Vertico
*** Vertico + Save-hist

The =vertico= package provides mini-buffer completion. Without it, for
instance, I am required to blindly type the name of the desired buffer
or file-path when calling ~switch-to-buffer~ or ~find-file~. Previous
completions are more quickly available

The =savehist= package saves the mini-buffer history so previous
completions are more quickly available.

*N.B.* The author recommends activating the packages in the ~:init~
section of =use-package= such that the mode gets enabled right
away. Note that this forces loading the package.

#+begin_src emacs-lisp :tangle modules/my-completion.el
;; Copied from https://github.com/minad/vertico
(use-package vertico
  :custom
  (vertico-cycle t "Return to top of list")
  (vertico-count 10 "N candidate suggestions")
  :hook (minibuffer-setup . vertico-repeat-save)
  :init (vertico-mode))

;; Persist history over Emacs restarts. Vertico sorts by history position.
(use-package savehist
  :init (savehist-mode 1))
#+end_src

*** Vertico-Directory

#+begin_src emacs-lisp :tangle modules/my-completion.el
;; Configure directory extension.
(use-package vertico-directory
  :after vertico
  :ensure nil
  ;; More convenient directory navigation commands
  :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src

** Marginalia

*N.B.* =nerd-icons= package added in [[*Icons][Icons]].

#+begin_src emacs-lisp :tangle modules/my-completion.el
;; Provides additional data to mini-buffer completion
(use-package marginalia
  :init (marginalia-mode 1))

;; Add nerd-icons to mini-buffer marginalia
(use-package nerd-icons-completion
  :after (marginalia nerd-icons)
  :config
  (nerd-icons-completion-mode)
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src

** Orderless

#+begin_src emacs-lisp :tangle modules/my-completion.el
;; Copied from https://github.com/oantolin/orderless/tree/master
(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

** Consult

#+begin_src emacs-lisp :tangle modules/my-completion.el
;; For adding extra functionality to the completion interfaces
(use-package consult
  :bind (;; C-c bindings in `mode-specific-map'
         ("C-c M-x" . consult-mode-command)
         ("C-c h" . consult-history)
         ("C-c k" . consult-kmacro)
         ("C-c m" . consult-man)
         ("C-c i" . consult-info)
         ([remap Info-search] . consult-info)
         ;; C-x bindings in `ctl-x-map'
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings in `goto-map'
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings in `search-map'
         ("M-s d" . consult-find)                  ;; Alternative: consult-fd
         ("M-s c" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :init
  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setopt register-preview-delay 0.5
          register-preview-function #'consult-register-format)
  ;; Optionally tweak the register preview window. This adds thin lines,
  ;; sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setopt xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

  :config
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis udsing the `consult-customize' macro.
  (consult-customize
   consult-theme
   :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-recent-file
   consult--source-project-recent-file
   :preview-key '("M-."))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setopt consult-narrow-key "<")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;;;; 1. project.el (the default)
  ;; (setopt consult-project-function #'consult--default-project--function)
  ;;;; 2. vc.el (vc-root-dir)
  ;; (setopt consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 3. locate-dominating-file
  ;; (setopt consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
  ;;;; 4. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setopt consult-project-function (lambda (_) (projectile-project-root))))
  )
#+end_src

** Provide my-completion.el

#+begin_src emacs-lisp :tangle modules/my-completion.el
(provide 'my-completion)

;;; my-completion.el ends here
#+end_src

* my-dev.el

#+begin_src emacs-lisp :tangle modules/my-dev.el
;;; -*- lexical-binding: t -*-
#+end_src

** Terminal

#+begin_src emacs-lisp :tangle modules/my-dev.el
;; Terminal emulator inside Emacs
(use-package vterm
  ;; Requires compilation, which may not work without installing dependencies
  :init (setopt vterm-always-compile-module t)
  :config
  (defun jh/vterm-new ()
  "Prompt the user for a new vterm buffer name and open it."
  (interactive)
  (let ((vterm-buffer-name (read-string "Enter new vterm buffer name: ")))
    (vterm (generate-new-buffer-name (concat "*" vterm-buffer-name "*"))))))
#+end_src

** Projectile-Mode

#+begin_src emacs-lisp :tangle modules/my-dev.el
;; To provide project management + navigation features
(use-package projectile
  :init (projectile-mode 1)
  :custom
  ;; Cache to prevent slow 'projectile-find-file' on larger projects
  (projectile-enable-caching t)
  :bind (:map projectile-mode-map
              ("C-c p" . projectile-command-map)))
#+end_src

** Lisp
*** Aggressive-Indent-Mode

No longer have to worry about indents getting messed up in emacs-lisp.

#+begin_src emacs-lisp :tangle modules/my-dev.el
;; Update indentation in response to changes to code
(use-package aggressive-indent
  :hook (emacs-lisp-mode))
#+end_src

** Yaml

#+begin_src emacs-lisp :tangle modules/my-dev.el
(use-package yaml-mode
  :mode ("\\.yml\\'" "\\.yaml\\'"))
#+end_src

** Provide my-dev.el

#+begin_src emacs-lisp :tangle modules/my-dev.el
(provide 'my-dev)

;;; my-dev.el ends here
#+end_src

* my-vc.el

#+begin_src emacs-lisp :tangle modules/my-vc.el
;;; -*- lexical-binding: t -*-
#+end_src

** Magit

The =magit= package is a texted-based user interface to Git (Git
Porcelain) inside Emacs [https://magit.vc/].

#+begin_src emacs-lisp :tangle modules/my-vc.el
(use-package magit
  :bind ("C-x g" . magit-status)
  :diminish magit-minor-mode
  :hook (git-commit-mode . (lambda () (setopt fill-column 72)))
  :mode ("/\\.gitmodules\\'" . conf-mode)
  :custom
  ;; hide ^M chars at the end of the line when viewing diffs
  (magit-diff-hide-trailing-cr-characters t)

  ;; Limit legth of commit message summary
  (git-commit-summary-max-length 50)

  ;; Open status buffer in same buffer
  (magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  :config
  (defun jh/magit-kill-all-buffers ()
    "Kill all buffers derived from 'magit-mode'."
    (interactive)
    (jh/kill-buffers-by-mode 'magit-mode)))
#+end_src

** Auto-Revert

#+begin_src emacs-lisp :tangle modules/my-vc.el
;; Switching branchs may change file on disk; if so, refresh buffers
(global-auto-revert-mode)
#+end_src

** Git-Gutter

#+begin_src emacs-lisp :tangle modules/my-vc.el
(use-package git-gutter
  :hook (prog-mode org-mode)
  :bind (("C-x P" . git-gutter:previous-hunk)
         ("C-x N" . git-gutter:next-hunk)
         ("C-x G" . git-gutter:popup-hunk))
  :config
  ;; Must include if 'linum-mode' activated (common in 'prog-mode')
  ;; because 'git-gutter' does not work with 'linum-mode'.
  (use-package git-gutter-fringe
    :commands git-gutter-mode
    :config (global-git-gutter-mode)))
#+end_src

** Provide my-vc.el

#+begin_src emacs-lisp :tangle modules/my-vc.el
(provide 'my-vc)

;;; my-vc.el ends here
#+end_src

* my-productivity.el

#+begin_src emacs-lisp :tangle modules/my-productivity.el
;;; -*- lexical-binding: t -*-
#+end_src

** Anzu-mode

The =anzu= package provides a minor mode which displays the "current
match" and "total matches" information in the mode-line.

#+begin_src emacs-lisp :tangle modules/my-productivity.el
(use-package anzu
  :hook (emacs-startup . global-anzu-mode)
  :custom
  (anzu-search-threshold 1000 "Limit n words searched to reduce lag")
  (anzu-replace-threshold 50 "Limit n replacement overlay to reduce lag")
  (anzu-minimum-input-length 2 "Increase activation threshold to reduce lag")

  ;; Cleanup mode-line information
  (anzu-mode-lighter "" "Remove mode-name from results")
  (anzu-replace-to-string-separator "")

  :bind (;; Keybindings M-% and C-M-% do not change
         ([remap query-replace] . anzu-query-replace)
         ([remap query-replace-regexp] . anzu-query-replace-regexp)

         :map isearch-mode-map
         ;; Use Anzu-mode for replacing from isearch results (C-s or C-f)
         ([remap isearch-query-replace] . anzu-isearch-query-replace)
         ([remap isearch-query-replace-regexp] . anzu-isearch-query-replace-regexp)))
#+end_src

** Avy

The =avy= package is useful for jumping to visible text using a
char-based decision tree.

#+begin_src emacs-lisp :tangle modules/my-productivity.el
(use-package avy
  :bind (("M-j" . avy-goto-char-timer)  ;; orig. 'default-indent-new-line'
         :map isearch-mode-map
         ("M-j" . avy-isearch))
  :custom
  (avy-timeout-seconds 0.3 "Seconds before overlay appears")
  (avy-style 'pre "Overyly single char at beginning of word")
  :custom-face
  ;; Change colors to improve readability
  (avy-lead-face ((t (:background "#000000" :foreground "#33A4FF" :weight bold)))))
#+end_src

** Type-break Mode

It is not healthy to sit all day; even worse to not take breaks to
eat/drink/stretch/walk. The built-in =type-break-mode= enforces a
pomodoro-style break routine.

#+begin_src emacs-lisp :tangle modules/my-productivity.el
(use-package type-break
  :hook (after-init)
  :custom
  (type-break-interval (* 50 60) "Work session duration")
  (type-break-good-break-interval (* 5 60) "Break duration")
  (type-break-good-rest-interval nil "Start break immediately")
  (type-break-keystroke-threshold '(nil . nil) "Break due to time, not keystroke")
  (type-break-file-name nil "Donot save break info")
  (type-break-query-mode t "Remind later, if break declined")
  (type-break-query-function 'y-or-n-p)
  (type-break-query-interval (* 10 60))
  (type-break-mode-line-message-mode t))
#+end_src

** Expand-Region

#+begin_src emacs-lisp :tangle modules/my-productivity.el
(use-package expand-region
  :commands er/expand-region
  :bind ("C-=" . er/expand-region))
#+end_src

** Helpful
:PROPERTIES:
:ID:       8fceb308-3d5f-4c30-bd85-105bc0d09ae7
:END:

The =Helpful= package is an alternative to the built-in Emacs and
provides a number of additional features such as more readable
doc-strings, and links to function calls and source-code.

#+begin_src emacs-lisp :tangle modules/my-productivity.el
;; Alternative to built-in Emacs help
(use-package helpful
  :after my-functions
  :bind (("C-h k" . helpful-kill-buffers)
         ("C-h j" . helpful-at-point)
         ("C-h f" . helpful-callable)
         ("C-h F" . helpful-function)
         ("C-h v" . helpful-variable)
         ("C-h k" . helpful-key)
         ("C-h c" . helpful-command)
         ("C-h m" . helpful-macro)
         ("C-h M" . describe-mode))
  :config
  (defun jh/helpful-kill-all-buffers ()
    "Kill all buffers derived from 'help-mode' or 'helpful-mode'."
    (interactive)
    (jh/kill-buffers-by-mode 'help-mode 'helpful-mode)))
#+end_src

** Provide my-productivity.el

#+begin_src emacs-lisp :tangle modules/my-productivity.el
(provide 'my-productivity)

;;; my-productivity.el ends here
#+end_src

* my-writing.el

#+begin_src emacs-lisp :tangle modules/my-writing.el
;;; -*- lexical-binding: t -*-
#+end_src

** Spell Check

Spell checking is important for both things like narratives and git
commits.  The [[https://github.com/minad/jinx][jinx]] package is preferred over the builtin =flyspell= due
to efficiency, keybindings, and ability to save words to a dictionary.

The package uses the API of the =Enchant= library [[[https://abiword.github.io/enchant/][github/enchant]]] and
only analyses visible text (instead of the entire buffer). The =jinx=
package requires the following local packages to provide
spell-checking. Both =enchant= and =pkgconf= are
Arch-specific. Dictionaries are provided by =nuspell= (the modern
version of =hunspell=). See [[https://github.com/minad/jinx][gitub/jinx]] for more details. In Arch,
packages can be download by ~yay enchant pkgconf hunspell~.

  + hunspell :: Spell-checker dictionaries
  + enchant :: Wrapper for spelling libraries
  + pkgconf :: Compiler; used by =jinx= to locate =enchant=

Useful commands include:
  + jinx-next / jinx-previous :: Jump to previous/next visible
    spelling error
  + jinx-correct-all :: Allow user to correct all spelling errors in
    buffer

*QUIRK:* Comments in =src-blocks= are only checked if viewed in an
=org-edit-special= buffer accessed via ~C-c '~ . This is because =jinx= only
checks text possessing specific face properties (see
~jinx-include-faces~ and ~jinx-exclude-faces~). When coding, we are only
interested in checking comments and doc-strings;
~tree-sitter-hl-face:comment~, for example extends this functionality to
=.py= files (see [[*Syntax Highlighting][Syntax Highlighting]]). To check a comment, we would need
to remove =org-block= in ~jinx-exclude-faces~ at the expense of checking
ALL of the code.

#+begin_src elisp :tangle modules/my-writing.el
(use-package jinx
  :hook (org-mode text-mode prog-mode conf-mode)
  :bind (("C-c j c" . jinx-correct)
         ("C-c j a" . jinx-correct-all)
         ;; alias defined using 'jinx-correct' keybinding
         ("C-c j d" . jinx-save-word-at-point))
  :custom
  ;; 'jinx-mode' only checks text possessing specific face properties like
  ;; 'font-lock-comment-face' in 'prog-mode' for example.
  (jinx-include-faces
   '((yaml-mode . conf-mode)
     (yaml-ts-mode . conf-mode)
     ;; Only check docstrings and comments; not strings
     (conf-mode font-lock-comment-face)
     (prog-mode font-lock-comment-face
                font-lock-doc-face
                tree-sitter-hl-face:comment
                tree-sitter-hl-face:doc)))

  (jinx-languages "en_GB")
  :config
  ;; Quickly save word-at-point to dictionary used by 'jinx'
  (defalias 'jinx-save-word-at-point (kmacro "C-c j c @ RET"))

  ;; 'jinx-correct' suggestions displayed as grid instead of long list
  (vertico-multiform-mode 1)
  (add-to-list 'vertico-multiform-categories
               '(jinx grid (vertico-grid-annotate . 20))))
#+end_src

** Denote

The =denote= package is a simple note-taking tool for Emacs that follows
a predictable and descriptive file-naming scheme. See [[denote:20241010T181237][How To Use
Denote]].

#+begin_src emacs-lisp :tangle modules/my-writing.el
(use-package denote
  :commands denote
  :hook (dired-mode . denote-dired-mode)
  :custom
  (denote-directory "~/notes/")
  (denote-file-type "org")
  (denote-prompts '(title keywords))
  (denote-known-keywords '("emacs" "python" "linux" "ml" "work"))
  ;; TODO: use separate templates for coding/ect
  (denote-templates nil)
  (denote-org-front-matter (concat "#+TITLE: %1$s\n"
                                   "#+DATE: %2$s\n"
                                   "#+ID: %4$s\n"
                                   "#+FILETAGS: %3$s\n"
                                   "#+STARTUP: overview\n"))
  :config
  ;; Good idea to update 'org-dblock' links/backlinks before saving buffers
  (add-hook 'before-save-hook (lambda ()
                                (when (denote-file-is-note-p (buffer-file-name))
                                  (org-update-all-dblocks)))))
#+end_src

The =consult-denote= package extends the preview-functionality of
=consult= and provides the following functions:

+ consult-denote-find :: Alternative to ~denote-open-or-create~
+ consult-denote-grep :: Regex to filter files in =denote-directory=

#+begin_src emacs-lisp :tangle modules/my-writing.el
(use-package consult-denote
  :after (consult denote)
  :commands (consult-denote-find))
#+end_src

** Provide my-writing.el

#+begin_src emacs-lisp :tangle modules/my-writing.el
(provide 'my-writing)

;;; my-writing.el ends here
#+end_src

* my-functions.el

#+begin_src emacs-lisp :tangle modules/my-functions.el
;;; -*- lexical-binding: t -*-
#+end_src

** Evaluate init.el

#+begin_src emacs-lisp :tangle modules/my-functions.el
;; Quickly re-evaluate init file
(defun jh/eval-init ()
  (interactive)
  (load-file user-init-file))
#+end_src

** Copy Buffer Name

#+begin_src emacs-lisp :tangle modules/my-functions.el
(defun jh/kill-buffer-name ()
  (interactive)
  (kill-new (buffer-name)))
#+end_src

** Copy Relative Buffer Path

#+begin_src emacs-lisp :tangle modules/my-functions.el
(defun jh/kill-relative-buffer-path ()
  "Copy relative buffer path to kill ring.

Replace '/home/<username>' prefix with '~' if applicable."
  (interactive)
  (if-let* ((full-path (buffer-file-name))
            (abbrev-path (abbreviate-file-name full-path)))
      (progn
        (kill-new abbrev-path)
        (message "Buffer path copied to kill ring: %s" full-path))
    (message "Buffer is not visiting a file.")))
#+end_src

** Create Org-Mode :file Link to Buffer

#+begin_src emacs-lisp :tangle modules/my-functions.el
(defun jh/kill-buffer-orgmode-file-link ()
  "Build [[:file file-path][file-name]] org-link from current
buffer.

The function 'buffer-file-name' returns the absolute path of the
buffer, which breaks should other users open the link. Instead,
the relative path is referenced using the 'abbreviate-file-name'
function."

  (interactive)
  (if-let ((absolute-path (buffer-file-name)))
      (kill-new (message "[[file:%s][%s]]"
                         (abbreviate-file-name absolute-path)
                         (buffer-name)))
    (message "Buffer is not a file")))
#+end_src

** Cleaning Buffer-List

*N.B.* ~M-x crux-kill-other-buffers~ to kill all buffers except current one

*** Kill Buffers Except BUFFER-NAME

#+begin_src emacs-lisp :tangle modules/my-functions.el
(defun jh/kill-buffers-except (buffer-name)
  "Kill all buffers except for BUFFER-NAME."
  (dolist (buffer (buffer-list))
    (unless (or (string-equal (buffer-name buffer) buffer-name)
                (string-equal (buffer-name buffer) (concat " " buffer-name)))
      (kill-buffer buffer))))
#+end_src

*** Kill Buffers Except SCRATCH

#+begin_src emacs-lisp :tangle modules/my-functions.el
(defun jh/kill-all-buffers-except-scratch ()
  "Kill all buffers except for *scratch*."
  (interactive)
  (jh/kill-buffers-except "*scratch*"))
#+end_src

*** Kill Buffers By Major-Mode

Quickly kill numerous =dired-mode= or =helpful-mode= buffers that
accumulate over time.

*N.B.* Mode-specific functions defined in relevant ~use-package~ calls,
including:

+ [[id:20596bd1-da74-408e-a84e-0b5b9f240398][my-dired.el]]
+ [[id:8fceb308-3d5f-4c30-bd85-105bc0d09ae7][Helpful]]

#+begin_src emacs-lisp :tangle modules/my-functions.el
(defun jh/kill-buffers-by-mode (&rest modes)
  "Kill all buffers derived from any of MODES.

Ex: (jh/kill-buffers-by-mode 'help-mode 'helpful-mode)"
  (let ((killed 0))
    (mapc (lambda (buffer)
            (with-current-buffer buffer
              (when (apply #'derived-mode-p modes)
                (kill-buffer buffer)
                (setq killed (1+ killed)))))
          (buffer-list))
    (message "Killed %d buffer(s) derived from %s" killed modes)))
#+end_src

** Jump to Configuration README.org

*N.B.* See related ~M-x crux-find-user-init-file~

#+begin_src emacs-lisp :tangle modules/my-functions.el
(defun jh/find-config-file ()
  "Edit '~/.emacs.d/README.org', in other window."
  (interactive)
  (find-file-other-window "~/.emacs.d/README.org"))
#+end_src

** Jump to Minibuffer

#+begin_src emacs-lisp :tangle modules/my-functions.el
(defun jh/jump-to-minibuffer ()
  "Switch to minibuffer window (if active)"
  (interactive)
  (when (active-minibuffer-window)
    (select-window (active-minibuffer-window))))
#+end_src

** Parse 'defcustom' of Elisp Files

#+begin_src emacs-lisp :tangle modules/my-functions.el
(defun jh/parse-package-defcustoms ()
  "Parse all `defcustom` variables and their docstrings in the
current buffer, and organize them in an `org-mode` description
list. The variables are sorted alphabetically, and only the first
sentence of each docstring is included."
  (interactive)
  (let ((output-buffer (get-buffer-create "*Parsed defcustom Variables*"))
        ;; Match 'defcustom' followed by the variable name
        (regex "^(defcustom\\s-+\\(\\_<[^[:space:]]+\\_>\\)")
        ;; To store matched defcustom variables and docstrings
        (result '()))
    ;; Search the current buffer for all occurrences of defcustom
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward regex nil t)
        (let ((var-name (match-string 1))
              docstring)
          ;; Move point to skip over the default value
          (forward-sexp)
          ;; Now search for the docstring (next string literal)
          (when (re-search-forward "\"\\([^\"]*\\)\"" nil t)
            (setq docstring (match-string 1)))
          ;; Extract only the first sentence of the docstring
          (when docstring
            (setq docstring (car (split-string docstring "\\.\\s-" t))))
          ;; Collect the variable name and docstring
          (push (list var-name docstring) result))))

    ;; Sort the collected variables alphabetically by name
    (setq result (sort result (lambda (a b) (string< (car a) (car b)))))

    ;; Insert the collected information into the temporary buffer with
    ;; org-mode formatting
    (with-current-buffer output-buffer
      (erase-buffer)
      (org-mode)  ;; Set buffer to org-mode
      (insert "#+TITLE: Parsed defcustom Variables\n\n")
      (dolist (item result)
        (let ((var-name (nth 0 item))
              (docstring (nth 1 item)))
          (insert (format "+ %s :: %s.\n\n" var-name docstring))))
      (goto-char (point-min)))
    (display-buffer output-buffer)
    (mark-whole-buffer)
    (fill-paragraph)))
#+end_src
** Provide my-functions.el

#+begin_src emacs-lisp :tangle modules/my-functions.el
(provide 'my-functions)

;;; my-functions.el ends here
#+end_src

* my-bindings.el

#+begin_src emacs-lisp :tangle modules/my-bindings.el
;;; -*- lexical-binding: t -*-
#+end_src

** Which-Key

The =which-key= minor-mode displays the available keybindings following
an incomplete command [[[https://github.com/justbur/emacs-which-key][github/whichkey]]]. For example, typing ~C-x~ will
open a window showing available keybindings (and descriptions) sharing
the ~C-x~ prefix.

*N.B.* After popup window appears, use ~C-h~ to open additional navigation
options. This is helpful not all keybindings can fit in the popup
window.

#+begin_src emacs-lisp :tangle modules/my-bindings.el
(use-package which-key
  :config (which-key-mode)
  :custom
  (which-key-show-early-on-C-h t     "Trigger which-key manually")
  (which-key-idle-delay 0.5          "Delay before popup appears")
  (which-key-idle-second-delay 0.05  "Responsiveness after triggered")
  (which-key-popup-type 'minibuffer  "Where to show which-key")
  (which-key-max-display-columns nil "N-cols determined from monotor")
  (which-key-separator "  "         "ex: C-x DEL backward-kill-sentence")
  (which-key-add-column-padding 1    "Padding between columns of keys")
  (which-key-show-remaining-keys t   "Show count of keys in modeline"))
#+end_src

** Crux

The "Collection of Ridiculously Useful eXtensions" =crux= package
bundles many useful interactive commands to enhance your overall Emacs
experience. There are many functions [[[https://github.com/bbatsov/crux/blob/master/crux.el][github.com/crux]]] to choose from.

Below, we add a number of useful functions:
  + crux-move-beginning-of-line :: Move point to indentation of line
  + crux-kill-line-backwards :: Kill line backwards and adjust the
    indentation
  + crux-switch-to-previous-buffer :: Switch to previously opened
    buffer
  + crux-view-url :: Open new buffer containing contents of URL

#+begin_src emacs-lisp :tangle modules/my-bindings.el
;; Collection of useful keybindings
(use-package crux
  :bind (([remap move-beginning-of-line] . 'crux-move-beginning-of-line)
         ([remap kill-whole-line] . 'crux-kill-whole-line)
         ("M-o" . 'crux-switch-to-previous-buffer)
         ("C-<backspace>" . 'crux-kill-line-backwards)
         ("C-c 3" . 'crux-view-url)))
#+end_src

** Global Bindings

#+begin_src emacs-lisp :tangle modules/my-bindings.el
;; 'Find-File-At-Point' package adds additional functionality to
;; existing keybindings
(ffap-bindings)

(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
(global-set-key (kbd "C-c C-;") 'copy-comment-region)
(global-set-key (kbd "C-x O") 'jh/jump-to-minibuffer)

;; Kill current buffer instead of selecting it from minibuffer
(global-set-key (kbd "C-x M-k") 'kill-current-buffer)
#+end_src

** General.el

Similar to =use-package=, the =general= package provides a more convenient
method for binding keys in Emacs.

#+BEGIN_src emacs-lisp :tangle modules/my-bindings.el
(use-package general
  :custom
  (general-describe-priority-keymaps nil)
  (general-describe-keymap-sort-function 'general-sort-by-car)
  (general-describe-keybinding-sort-function 'general-sort-by-car)

  :config
  ;; Good to unset before assigning to 'my-leader-def'
  (global-unset-key (kbd "M-m"))

  (general-create-definer my-leader-def
    :keymaps 'global
    :prefix "M-m"))

;; :ignore t to define sub-section headers
(my-leader-def

  ;; BUFFERS
  "b"  '(:ignore t                        :which-key "buffer")
  "bn" '(jh/kill-buffer-name              :which-key "get-buffer-name")
  "bp" '(jh/kill-relative-buffer-path     :which-key "get-relative-path")
  "bl" '(jh/kill-buffer-orgmode-file-link :which-key "get-buffer-orgmode-link")
  "bi" '(crux-find-user-init-file         :which-key "jump-to-init")
  "bc" '(jh/find-config-file              :which-key "jump-to-config")
  "bf" '(ffap-other-window                :which-key "find-file-other-window")

  ;; KILL BUFFERS
  "k"  '(:ignore t                          :which-key "killing")
  "ka" '(jh/kill-all-buffers-except-scratch :which-key "kill-all-buffers")
  "ke" '(crux-kill-other-buffers            :which-key "kill-buffers-except-current"))
#+end_src

** Provide my-bindings.el

#+begin_src emacs-lisp :tangle modules/my-bindings.el
(provide 'my-bindings)

;;; my-bindings.el ends here
#+end_src

* Conclusion
:PROPERTIES:
:ID:       8b5ba82d-d303-4970-ade6-39f82fc08b56
:END:

Finally, we specify the packages (ie top-level org-headers) to be
included in our configuration.

#+begin_src emacs-lisp :tangle init.el
;; Add configuration modules to load path
(add-to-list 'load-path (expand-file-name "modules" user-emacs-directory))

;; Load Pertinent Modules
(require 'my-visuals)
(require 'my-org)
(require 'my-completion)
(require 'my-bindings)
(require 'my-vc)
(require 'my-writing)
(require 'my-productivity)
(require 'my-dev)
(require 'my-functions)
(require 'my-dired)

;;; init.el ends here
#+end_src
